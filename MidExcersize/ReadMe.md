# examples
## 1. Text Editor

## 2. Fashion

## 3. 주소 복원 
[심볼 테이블 구축]

a. 256 개 중 32 개만이 주소 구성에 사용 : 인덱스 테이블, 역 인덱스 테이블

b. 32개의 인덱스로 구성된 Trie 이용

c. 주소가 최대 20,000 개 주어지고, 이를 Trie 에 삽입

[하나의 주소가 주어진 경우, 복원]

Trie 순회하면서 depth 별 노드가 갖는 가능한 문자 집합과 아래의 케이스를 비교해서 

만족하는 경우에만 자식 노드 순회시킴. 

마지막 depth 까지 모두 내려가는 것은 해당 케이스를 만족하는 경우가 있다는 것이고, 이 것이 terminal node 이면 복원 성공

(조건-1) 노드가 갖는 자식 노드들의 인덱스가 가리키는 문자가 해당 depth 의 주어진 주소의 문자인 경우

(조건-2) 해당 depth 의 주어진 주소의 문자를 각 비트별로 반전 시킨 경우 이것이 자식 노드들의 인덱스가 가리키는 문자와 일치하는 모든 경우

# Certificate Review

## 1. 4/28 Memo Note

[문제 설명]

a. 메모는 y, x, height, width 와 표기될 문자열을 갖음. 문자열은 메모 영역을 넘도록 길게 주어질 수 도 표현 가능 문자열보다 적게 주어질 수 있음

b. 새로운 메모는 기존 메모보다 z-order 상 앞에 존재. 곂쳐지지는 않는 부분은 z-order 상 뒤의 메모 내용이 보임

c. 메모를 대상으로 이동, 크기 및 문자열 변경, 선택이 가능하고 이것들을 하고 나면 해당 메모가 z-order 상 제일 앞에 나옴

d. 좌표 y,x 가 주어지면 x,y 를 좌상단으로하는 5x5 크기 영역의 화면 상태를 출력

[접근 방식]

a. rectangle tree (영역의 포함 관계 = 부모 관계) 를 기본으로하고 tree 에 추가 하지 못하는 경우 새로운 tree 를 만들어 추가하고 이를 list 로 묶어 관리

b. 또는 화면 영역 NxN 의 linked list 배열을 만들고 메모 추가/이동/변경 시 메모가 차지하는 영역 셀을 메모 인덱스로 업데이트

==> b 방식이 a 방식보다 구현 측면에서 매우 간결함

[복기]

a. 객체의 index 를 별도 관리해야 하는 경우, index 객체는 인덱스를 추가할때마다 생성, 추가해야 함. 

b. linked list 를 배열로 관리하는 경우, 각 배열 요소에 빈 linked list 생성하지 않고 추가되는 시점에 생성하여 추가하고자 한다면
   
   array[[y]][x] 가 null 이 될 수 있음을 반드시 명심. 영역이 주어지고 영역 내의 인스턴스를 업데이트 하는 경우 null 이 되는 영역 셀이 존재함을 명심
